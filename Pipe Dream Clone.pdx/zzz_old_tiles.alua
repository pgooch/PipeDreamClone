-- Define some variables for the board
PLAYFIELD_OFFSET = { X = 126, Y = 22 };
PLAYFIELD_SIZE = { X = 10, Y = 8 };
PREVIEW_COUNT = 5;
INDEX__PREVIEW = PLAYFIELD_SIZE.X*PLAYFIELD_SIZE.Y+1;
INDEX__HOLD = PLAYFIELD_SIZE.X*PLAYFIELD_SIZE.Y+PREVIEW_COUNT+1;

tiles = {}

-- Get everything ready for a new game
function initializeTiles()

	-- First just create the basics for the playfield and preview
	for n = 1,(PLAYFIELD_SIZE.X*PLAYFIELD_SIZE.Y)+PREVIEW_COUNT+1 do -- All are stored inthe single playfield object, first group is the field, then preview, then hold
		tiles[n] = {}

		-- Handle the X/Y, N, and index for future reference
        tiles[n].X = ((n-1) % PLAYFIELD_SIZE.X) + 1;
        tiles[n].Y = math.floor((n-1)/PLAYFIELD_SIZE.X) + 1;
        tiles[n].N = n;

		-- Prepare the sprite
		tiles[n].sprite = GFX.sprite.new(PIPE_GFX_TABLE);
		tiles[n].sprite:setZIndex( 1000 + n );
		updateTile( n, 0 );
		tiles[n].sprite:setCenter(0.5, 0.5);
		tiles[n].sprite:add();
	end

	-- Move all the playfield sprites 14
	for n = 1,(PLAYFIELD_SIZE.X*PLAYFIELD_SIZE.Y) do
		tiles[n].sprite:moveTo( PLAYFIELD_OFFSET.X + ((tiles[n].X-1)*28), PLAYFIELD_OFFSET.Y + ((tiles[n].Y-1)*28) );
	end
	-- Move the Preview sprites
	for n = PREVIEW_COUNT-1,0,-1 do
		local x = 89 - (n*28);
		if x < 16 then x -= 1 end -- breaks grid if negative
		tiles[INDEX__PREVIEW+n].sprite:moveTo( x ,PLAYFIELD_OFFSET.Y );
	end
	-- Move the hold sprite
	tiles[INDEX__HOLD].sprite:moveTo(89 ,59);

	-- get the needed number of preview peices and place them
	for n = 1,PREVIEW_COUNT do
		-- previewAdd();
	end
end





-- BLANK_TILE_SPRITE = PIPE_GFX_TABLE[1];
-- TILES = {
--     {
--         name = "Horizontal";
--         sprites = {
--             empty = PIPE_GFX_TABLE[2];
--             full = PIPE_GFX_TABLE[8];
--         };
--         rotation = 0;
--         paths = { N = " ", S = " ", E = "W", W = "E" };
--     },
--     {
--         name = "Vertical";
--         sprites = {
--             empty = PIPE_GFX_TABLE[2];
--             full = PIPE_GFX_TABLE[8];
--         };
--         rotation = 90;
--         paths = { N = "S", S = "N", E = " ", W = " " };
--     },
--     {
--         name = "CurveNW";
--         sprites = {
--             empty = PIPE_GFX_TABLE[3];
--             full = PIPE_GFX_TABLE[9];
--         };
--         rotation = 90;
--         paths = { N = "W", S = " ", E = " ", W = "N" };
--     },
--     {
--         name = "CurveNE";
--         sprites = {
--             empty = PIPE_GFX_TABLE[3];
--             full = PIPE_GFX_TABLE[9];
--         };
--         rotation = 180;
--         paths = { N = "E", S = " ", E = "N", W = " " };
--     },
--     {
--         name = "CurveSE";
--         sprites = {
--             empty = PIPE_GFX_TABLE[3];
--             full = PIPE_GFX_TABLE[9];
--         };
--         rotation = 270;
--         paths = { N = " ", S = "E", E = "S", W = " " };
--     },
--     {
--         name = "CurveSW";
--         sprites = {
--             empty = PIPE_GFX_TABLE[3];
--             full = PIPE_GFX_TABLE[9];
--         };
--         rotation = 0;
--         paths = { N = " ", S = "W", E = " ", W = "S" };
--     },
--     {
--         name = "Cross";
--         sprites = {
--             empty = PIPE_GFX_TABLE[4];
--             full = PIPE_GFX_TABLE[5];
--         };
--         rotation = 0;
--         paths = { N = "S", S = "N", E = "W", W = "E" };
--     },
-- }

-- ANIMATION_DELETE_LENGTH = 20;

-- animatingTiles = {};

-- check if there is a tile at a location
function isTileAt(x,y)
	local n = ((y-1) * PLAYFIELD_X) + x;
	return playfield[n].index > 0;
end

-- Get a tile from the playfield stack
-- function getTileAt(x,y)
-- 	local n = ((y-1) * PLAYFIELD_X) + x;
-- 	return getTile(n);
-- end
-- function getTile(n)
--     if n < 0 then
--         return {
--             name = "Empty";
--             sprites = {
--                 empty = PIPE_GFX_TABLE[1];
--             };
--             rotation = 0;
--             paths = { N = " ", S = " ", E = " ", W = " " };
--             index = -1;
--         };
--     elseif TILES[n] then
--         local tile = TILES[n];
--         tile.index = n;
--         return tile;
--     else -- 0 is error, but so it other things
--         return {
--             name = "Error!";
--             sprites = {
--                 empty = PIPE_GFX_TABLE[7];
--             };
--             rotation = 0;
--             paths = { N = " ", S = " ", E = " ", W = " " };
--             index = 0;
--         };
--     end
-- end

-- Ways to update tiles, will update the sprite graphics and all the associated data
function updateTileAt(x, y, new)
	local n = ((y-1) * PLAYFIELD_X) + x;
	updateTile(n, new);
end
function updateTile(n, new)
	local originalTile = getTileDetails(new);
	for k, v in pairs(originalTile) do
		if k ~= "sprite" then
			if type(v) == "table" then
				tiles[n][k] = table.shallowcopy(v)
			else
				tiles[n][k] = v
			end
		end
	end
	tiles[n].sprite:setImage(originalTile.sprites.empty);
	tiles[n].sprite:setRotation(originalTile.rotation);
end

-- Ways to replace tiles with new tiles
function replaceTileAt(x, y, new)
	local n = ((y-1) * PLAYFIELD_X) + x;
	replaceTile(n, new);
end
function replaceTile(n, new)
    if playfield[n].index > 0 then
        cursorSprite.lock = true;
        animatingTiles[n] = {
            tileIndex = n,
            animation = "delete",
            frame = ANIMATION_DELETE_LENGTH,
            unlockOnFinish = true,
            replaceOnFinish = true
        }
    end
end

-- Ways to get random tiles
-- function randomTileIndex()
--     return math.random(1,7)
-- end
-- function randomTile()
--     local index = randomTileIndex();
--     local tile = TILES[index];
--     tile.index = index
--     return tile;
-- end

-- Ways to interact with the hold system
function haveHold()
    return playfield[HOLD_INDEX_START].index > 0
end
function addHold(x, y)
	local n = ((y-1) * PLAYFIELD_X) + x;
    updateTile(HOLD_INDEX_START, playfield[n].index)
    updateTileAt(x, y, -1)


        print( 'center', playfield[n].sprite:getCenter(), 'size',  playfield[n].sprite:getSize() )

end
function placeHold(x, y)
    updateTileAt(x, y, playfield[HOLD_INDEX_START].index)
    updateTile(HOLD_INDEX_START, -1)
end

-- Handles the tiles animations, used for deleteing and the like
function tileAnimationUpdate()
    for n in pairs(animatingTiles) do
        animatingTiles[n].frame -= 1;

        if animatingTiles[n].animation == "delete" then
            local scaleFacor = 1 - math.abs(animatingTiles[n].frame - ANIMATION_DELETE_LENGTH)/ANIMATION_DELETE_LENGTH
            playfield[n].sprite:setScale(scaleFacor)
            playfield[n].sprite:setRotation(-360*scaleFacor)
        end

        -- animation complete, close ups
        if animatingTiles[n].frame == 0 then
            if animatingTiles[n].replaceOnFinish then
                updateTile(n, playfield[PREVIEW_INDEX_START].index)
                previewAdd()
            end
            if animatingTiles[n].unlockOnFinish then
                cursorSprite.lock = false;
            end
            playfield[n].sprite:setScale(1)
            playfield[n].sprite:setRotation(0)
            animatingTiles[n] = nil;
        end
    end
end
